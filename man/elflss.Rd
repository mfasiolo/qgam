% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/elflss.R
\name{elflss}
\alias{elflss}
\title{Extended log-F model with variable scale}
\usage{
elflss(link = list("identity", "log"), qu, lam, theta, remInter = TRUE)
}
\arguments{
\item{link}{vector of two characters indicating the link function for the quantile location and for the log-scale.}

\item{qu}{parameter in (0, 1) representing the chosen quantile. For instance, to fit the median choose \code{qu=0.5}.}

\item{lam}{parameter lambda of the ELF density, it must be positive. See Fasiolo et al. (2017) for details.}

\item{theta}{a scalar representing the intercept of the model for the log-scale log(sigma).}

\item{remInter}{if TRUE the intercept of the log-scale model is removed.}
}
\value{
An object inheriting from mgcv's class \code{general.family}.
}
\description{
The \code{elflss} family implements the Extended log-F density of Fasiolo et al. (2017) and it is supposed
             to work in conjuction with the general GAM fitting methods of Wood et al. (2017), implemented by
             \code{mgcv}. It differs from the \code{elf} family, because here the scale of the density 
             (sigma, aka the learning rate) can depend of the covariates, while in 
             while in \code{elf} it is a single scalar. At the moment the family is mainly intended for internal use, 
             use the \code{qgam} function to fit quantile GAMs based on ELF.
}
\details{
This function is meant for internal use only.
}
\examples{
set.seed(651)
n <- 5000
x <- seq(-4, 3, length.out = n)
X <- cbind(1, x, x^2)
beta <- c(0, 1, 1)
sigma =  1.2 + sin(2*x)
f <- drop(X \%*\% beta)
dat <- f + rnorm(n, 0, sigma)
dataf <- data.frame(cbind(dat, x))
names(dataf) <- c("y", "x")

# Fit median using elf directly: NOT RECOMMENDED
fit <- gam(list(y~s(x, k = 30, bs = "cr"), ~ s(x, k = 30, bs = "cr")), 
           family = elflss(theta = -1.16, lam = 0.5, qu = 0.5), 
           data = dataf)
           
plot(x, dat, col = "grey", ylab = "y")
tmp <- predict(fit, se = TRUE)
lines(x, tmp$fit[ , 1])
lines(x, tmp$fit[ , 1] + 3 * tmp$se.fit[ , 1], col = 2)
lines(x, tmp$fit[ , 1] - 3 * tmp$se.fit[ , 1], col = 2)     

# Use qgam: RECOMMENDED
fit <- qgam(list(y~s(x, k = 30, bs = "cr"), ~ s(x, k = 30, bs = "cr")), 
            data = dataf, qu = 0.95, 
            lsig = -1.16) # <- sloppy tolerance to speed up calibration 

plot(x, dat, col = "grey", ylab = "y")
tmp <- predict(fit, se = TRUE)
lines(x, tmp$fit[ , 1])
lines(x, tmp$fit[ , 1] + 3 * tmp$se.fit[ , 1], col = 2)
lines(x, tmp$fit[ , 1] - 3 * tmp$se.fit[ , 1], col = 2)
}
\author{
Matteo Fasiolo <matteo.fasiolo@gmail.com> and Simon N. Wood.
}
\references{
Fasiolo, M., Goude, Y., Nedellec, R. and Wood, S. N. (2017). Fast calibrated additive quantile regression. 
            Available at \url{https://github.com/mfasiolo/qgam/blob/master/draft_qgam.pdf}.
            
            Wood, Simon N., Pya, N. and Safken, B. (2017). Smoothing parameter and model selection for 
            general smooth models. Journal of the American Statistical Association.
}

